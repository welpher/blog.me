import{_ as i,c as l,o as t,U as e}from"./chunks/framework.I0qYP7JU.js";const c=JSON.parse('{"title":"页面合成的一些兼容问题（hasLayout）","description":"","frontmatter":{"title":"页面合成的一些兼容问题（hasLayout）","tags":null,"id":723,"author":"welpher.yu","categories":["web前端"],"date":"2012-02-05T22:08:14.000Z"},"headers":[],"relativePath":"posts/2012/723.md","filePath":"posts/2012/723.md"}'),a={name:"posts/2012/723.md"},o=e("<p>最近在学习html合成，标准浏览器倒是很好解决，但是像ie众多占有率很高的浏览器却要花很多心思。按照我的一位同事说的：他是被蹂躏了两年才得心应手的。</p><p>我翻了以前的一些笔记，我也是有记的，而且很有用。有网上搜的，有同事的经验。</p><p>------------------------------------------------分割线--------------------------------------------------------</p><p>IE对CSS的渲染引擎hasLayout：在InternetExplorer中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。为了调节这两个不同的概念，渲染引擎采用了 hasLayout 的属性，属性值可以为true或false。当一个元素的 hasLayout属性值为true时，我们说这个元素有一个布局（layout）。当一个元素有一个布局时，它负责对自己和可能的子孙元素进行尺寸计算<br> 和定位。简单来说，这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作。</p><p>负责组织自身内容的元素将默认有一个布局，主要包括以下元素（不完全列表）：</p><ul><li>body and html</li><li>table, tr, th, td</li><li>img</li><li>hr</li><li>input, button, file, select, textarea, fieldset</li><li>marquee</li><li>frameset, frame, iframe</li><li>objects, applets, embed<br> （对于并非所有的元素都默认有布局，微软给出的主要原因是“性能和简洁”。如果所有的元素都默认有布局，会对性能和内存使用上产生有害的影响。）</li></ul><p>**如何激发 haslayout？<br> ** 大部分的 IE 显示错误，都可以通过激发元素的 haslayout 属性来修正。可以通过设置 css 尺寸属性(width/height)等来激发元素的 haslayout，使其“拥有布局”。如下所示，通过设置以下 css 属性即可。</p><ul><li>display: inline-block</li><li>height: (任何值除了auto)</li><li>float: (left 或 right)</li><li>position: absolute</li><li>width: (任何值除了auto)</li><li>writing-mode: tb-rl</li><li>zoom: (除 normal 外任意值)<br> Internet Explorer 7 还有一些额外的属性(不完全列表):</li><li>min-height: (任意值)</li><li>max-height: (除 none 外任意值)</li><li>min-width: (任意值)</li><li>max-width: (除 none 外任意值)</li><li>overflow: (除 visible 外任意值)</li><li>overflow-x: (除 visible 外任意值)</li><li>overflow-y: (除 visible 外任意值)</li><li>position: fixed</li></ul><p>其中 overflow-x 和 overflow-y 是 css3 盒模型中的属性，目前还未被浏览器广泛支持。对于内联元素(默认即为内联的元素，如 span，或 display:inline; 的元素)，width 和 height 只在 IE5.x 下和 IE6 或更新版本的 quirks 模式下触发 hasLayout 。而对于IE6，如果浏览器运行于标准兼容模式下，内联元素会忽略 width 或 height 属性，所以设置 width 或 height不能在此种情况下令该元素具有 layout。</p><p>zoom 总是可以触发 hasLayout，但是在 IE5.0 中不支持。</p><p>具有“layout” 的元素如果同时 display: inline ，那么它的行为就和标准中所说的 inline-block很类似了：在段落中和普通文字一样在水平方向和连续排列，受 vertical-align影响，并且大小可以根据内容自适应调整。这也可以解释为什么单单在 IE/Win 中内联元素可以包含块级元素而少出问题，因为在别的浏览器中display: inline 就是内联，不像 IE/Win 一旦内联元素拥有 layout 还会变成 inline-block。<br> ** haslayout 问题的调试与解决<br> ** 当网页在 IE 中有异常表现时，可以尝试激发 haslayout 来看看是不是问题所在。常用的方法是给某元素 css 设定 zoom:1。使用 zoom:1 是因为大多数情况下，它能在不影响现有环境的条件下激发元素的 haslayout。而一旦问题消失，那基本上就可以判断是haslayout 的原因。然后就可以通过设定相应的 css 属性来对这个问题进行修正了。建议首先要考虑的是设定元素的width/height 属性，其次再考虑其他属性。<br> 对 IE6 及更早版本来说，常用的方法被称为霍莉破解(Holly hack)，即设定这个元素的高度为 1%(height:1%😉。需要注意的是，当这个元素的 overflow 属性被设置为 visible 时，这个方法就失效了。或者使用 IE的条件注释。</p><p>对 IE7 来说，最好的方法时设置元素的最小高度为 0 (min-height:0;)。<br> haslayout 问题引起的常见 bug<br> IE6 及更低版本的双空白边浮动 bug（float)<br> bug 修复: display:inline;<br> IE5-6/win 的 3 像素偏移 bug<br> bug 修复: _height:1%;<br> 当浮动元素与非浮动元素相邻时，这个3像素的Bug就会出现，它会偏移3像素。<br> 只要触发IE的hasLayout，非浮动元素就会拥有布局。所以，利用IE6特有的hack规则，为它单独写样式就可修复此问题：</p><p>_zoom:1;<br> margin-left:value;<br> _margin-left: value-3px;<br> zoom 是IE触发Layout条件之一，因为它是IE特有的CSS规则，所以采用zoom。<br> margin-left: value-3px 是修复IE6 中3px的bug。<br> E6 的躲躲猫(peek-a-boo) bug<br> bug 修复: _height:1%;</p><p>PS：很早以前复制的笔记，不知道地址了。</p>",14),s=[o];function r(h,n,p,u,b,d){return t(),l("div",null,s)}const _=i(a,[["render",r]]);export{c as __pageData,_ as default};
