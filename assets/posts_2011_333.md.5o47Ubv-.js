import{_ as s,c as p,a as e,m as t,U as n,o as a}from"./chunks/framework.I0qYP7JU.js";const W=JSON.parse('{"title":"javascript DOM事件模型","description":"","frontmatter":{"title":"javascript DOM事件模型","tags":["dom","JavaScript","事件模型"],"id":333,"author":"welpher.yu","categories":["web前端"],"date":"2011-11-03T15:00:21.000Z"},"headers":[],"relativePath":"posts/2011/333.md","filePath":"posts/2011/333.md"}'),o={name:"posts/2011/333.md"},r=t("p",null,"前些天有人电话里问我dom事件模型，其实这个东西我之前肯定是有看过，好好的理过的。只不过，公司面对的客户群就是纯ie的的客户，所以对标准浏览器的事件模型给忘记了。当时只回答了ie下是冒泡（Bubbling），标准浏览器是捕获（Capture）。",-1),l=t("p",null,"回头去搜了一下，标准浏览器还有一个冒泡（Bubbling）的过程。而Netscape Navigatior才只有捕获。",-1),i=t("p",null,"我们都知道DOM(文档对象模型)是一个树形结构，当一个html元素产生一个事件时，这个事件会在元素节点与根节点之间的路径传播，路径中的节点都会触发这个事件。",-1),c=t("p",null,[t("strong",null,"DOM事件模型主要有三种模型：冒泡、捕获和标准事件模型。")],-1),d=t("p",null,"之前浏览器都是有自己的事件模型，到DOM Level3后，才陆陆续续的支持DOM标准的事件模型，即捕获与冒泡型。这两种事件模型肯定是各有优缺点了，所以标准浏览器的事件模型会采用两者的结合体。现在主流的浏览器firefox,opera,safari都支持标准的DOM事件处理模型，而ie仍使用自己的模型。",-1),u=t("div",{style:{display:"none"}},"[html] [/html]",-1),_=t("pre",{class:"brush: html; gutter: true; first-line: 1"},`<div class="wrapper">
	<div class="head">
		head
	</div>
	<div class="mainbody" >
		lalsdfjasdk jfklsdajf lkasjdf  dsf sdf <br/>
		lalsdfjasdk jfklsdajf lkasjdf<br/>
		lalsdfjasdk jfklsdajf lkasjdf<br/>
	<button class="btn">button</button>
	</div>
</div>`,-1),h=t("p",null,"button.btn - > div.mainbody - > div.wrapper - > body - >document",-1),v=t("p",null,"在标准浏览器下事件的传播路径会是这样：",-1),b=t("p",null,"window - > document - > body - > div.wrapper - > div.mainbody - > button.btn",-1),f=t("ul",null,[t("li",null,"> div.mainbody - > div.wrapper - > body - >document - > window")],-1),m=t("p",null,"javascript使用事件驱动，先给一个元素添加事件监听函数，当这个元素的对应事件对触发后，就会调用添加的事件监听函数。",-1),y=t("p",null,"下面就是javascript中给元素添加事件监听函数的方法：",-1),M=t("p",null,"直接在html元素上添加",-1),w=t("div",{style:{display:"none"}},"[html] [/html]",-1),D=t("pre",{class:"brush: html; gutter: true; first-line: 1"},'<button id="sbtBtn" onclick="btnClick();" class="btn">button</button>',-1),O=t("div",{style:{display:"none"}},"[javascript] [/javascript]",-1),g=t("pre",{class:"brush: javascript; gutter: true; first-line: 1"},`document.getElementById("sbtBtn").onclick = function(){
//add your code
}`,-1),j=t("div",{style:{display:"none"}},"[javascript] [/javascript]",-1),k=t("pre",{class:"brush: javascript; gutter: true; first-line: 1"},`document.getElementById("sbtBtn").addEventListener("click",
    function(){
//add your code
    },true);`,-1),E=n(`<span style="color:#3366ff;">关于这个区别，我在最近的技术支持的过程中有一点体会。这也是我立马来看DOM事件模型的原因了。</span><p>** DOM Level 0**</p><p>像上面前两种方式，都是这个级别的事件模型了。一般说来，在这个监听函数里返回一个false值，会阻止浏览器默认的执行动作，this指向目标元素。</p><blockquote><p>从技术上来说，W3C的DOM标准并不支持上述最原始的添加事件监听函数的方式，这些都是在DOM标准形成前的事件模型。尽管没有正式的W3C标准，但这种事件模型仍然得到广泛应用，这就是我们通常所说的0级DOM。</p><p>DOM 级别 0 不是 W3C 规范。而仅仅是对在 Netscape Navigator 3.0 和 Microsoft Internet Explorer 3.0 中的等价功能性的一种定义。</p><p>DOM 发展过程中的关键角色有：ArborText、IBM、Inso EPS、JavaSoft、Microsoft、Netscape、Novell、the Object Management Group、SoftQuad、Sun Microsystems 以及 Texcel。</p><p>W3C 的 DOM 级别 1 建立于此功能性之上。 <strong>DOM Level 1</strong></p></blockquote><p>DOM级别1于1998年10月1日成为W3C推荐标准。1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。** **</p><blockquote><p>DOM 级别 1 专注于 HTML 和 XML 文档模型。它含有文档导航和处理功能。</p><p>DOM 级别 1 于 1998 年 10 月 1 日成为 W3C 推荐标准。</p><p>第二版的工作草案在 2000 年 9 月 29 日。 **DOM Level 2 **</p></blockquote><p>如前面所述，标准浏览器分捕获和冒泡两个阶段，前面添加事件监听的第三种方法就是这个级别的实现方式。但是这个方法我们还要详细的去探究这个方法的用法：</p><p>addEventListener(eventType,handler,useCapture)，有三个参数，其中第三个参数决定了事件的注册函数在哪个事件传播阶段触发，如果为true则在捕获阶段，反之则在冒泡阶段。当一个目标注册了捕获阶段的监听函数，如果其祖先节点也注册了，那么在传播的过程中就会执行这些函数。</p><p>在执行监听函数时，会传入一个event对象，其实有一些常用的属性我们会经常用到：</p><p>type:</p><p><span style="white-space:pre;"></span>发生事件的类型，如click , mouseover, mouseout等</p><p>target：</p><p><span style="white-space:pre;"></span>发生事件的节点可能与currentTarget不同</p><p>currentTarget:</p><p><span style="white-space:pre;"></span>正在处理事件的节点，如果在capturing阶段和冒泡阶段处理事件，这个属性就与target属性不同。在事件监听函数中应该用这个属性而不是this</p><p>stopPropagation():</p><p><span style="white-space:pre;"></span>可以阻止事件从当前正在处理他的节点传播</p><p>preventDefault():</p><p><span style="white-space:pre;"></span>阻止浏览器执行与事件相关的默认动作，与0级DOM中返回false一样</p><p>clientX, clientY:</p><p><span style="white-space:pre;"></span>鼠标相对于浏览器的x坐标y坐标</p><p>screenX, screenY:</p><p><span style="white-space:pre;"></span>鼠标相对于显示器左上角的x坐标y坐标</p><p><strong>IE下的处理方式</strong></p><p>IE下没有addEventListener，但是有自己类似的方法：attachEvent，这个方法只有两个参数，第一个参数为事件类型的前面需要加&quot;on&quot;，由于 ie下没有捕获，所以没有类似标准浏览器的第三个参数。</p><p>IE上可以对元素进行多次同样的绑定，标准浏览器只会绑定一次。ie下event对象不是事件处理程序传入的参数，而是全局的变量:window.event，例如中断冒泡用window.event.cancelBubble = true.</p><p>event常用属性</p><p>type: <span style="white-space:pre;"></span>兼容DOM的type属性</p><p>srcElement:</p><p><span style="white-space:pre;"></span>兼容DOM的target属性</p><p>clientX, clientY:</p><p><span style="white-space:pre;"></span>兼容DOM的clientX, clientY属性</p><p>cancelBubble:</p><p><span style="white-space:pre;"></span>布尔值，设为true同调用stopPropagation()</p><p>returnValue:</p><p><span style="white-space:pre;"></span>布尔值，设为false同调用preventDefault()</p><p>卸载方法</p><pre class="brush: javascript; gutter: true; first-line: 1">Object.removeEventListener(eventType,handler,useCapture);//DOM标准的事件卸载方式
Object.detachEvent(eventType,handler);//IE内核的事件卸载方式</pre><p>关于事件类型，各大浏览器支持的情况：<a href="http://www.quirksmode.org/dom/events/" title="Event compatibility tables" target="_blank" rel="noreferrer">Event compatibility tables</a></p><p>参考 ：</p><p>1、<a href="http://www.w3school.com.cn/w3c/w3c_dom.asp" title="W3C DOM 活动" target="_blank" rel="noreferrer">W3C DOM 活动</a></p><p>2、《JavaScript高级程序设计（第2版）》</p>`,42);function T(C,B,I,N,S,x){return a(),p("div",null,[r,l,i,c,d,u,_,e(" 这段html代码在IE下事件的传播路径（冒泡）是这样的： "),h,v,b,f,m,y,M,w,D,e(" 用相应的js属性 "),O,g,e(" 用注册函数 "),j,k,e(" 这三种方法在作用域以及事件传播等都是有区别，而这个区别就是DOM level 0 ,DOM level 2事件模型的区别了。"),E])}const q=s(o,[["render",T]]);export{W as __pageData,q as default};
